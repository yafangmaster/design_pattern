### 4、装饰者模式\(Decorator\)

我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。在这里我们可以通过使用装饰者模式来解决这个问题。

装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。

[![](http://images.cnitblog.com/blog/381060/201310/08191404-6db8b93b3bca47c9b58df0675ebff352.png "装饰者模式")](http://images.cnitblog.com/blog/381060/201310/08191403-9fbb57e09b5a40e489a713f90b8f145a.png)

参与者：

Component: 抽象构件。是定义一个对象接口，可以给这些对象动态地添加职责。

ConcreteComponent:具体构件。是定义了一个具体的对象，也可以给这个对象添加一些职责。

Decorator: 抽象装饰类。是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。

ConcreteDecorator:具体装饰类，起到给Component添加职责的功能。



