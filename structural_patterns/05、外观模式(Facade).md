### 5、外观模式\(Facade\)

我们都知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。外观模式非常好的诠释了这段话。外观模式提供了一个统一的接口，用来访问子系统中的一群接口。它让一个应用程序中子系统间的相互依赖关系减少到了最少，它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。

通过使用外观模式，使得客户对子系统的引用变得简单了，实现了客户与子系统之间的松耦合。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。

[![](http://images.cnitblog.com/blog/381060/201310/08191405-52d7986f49484723803d84fab3065082.png "外观模式")](http://images.cnitblog.com/blog/381060/201310/08191405-c300a2b1a31a4e579fcfca4be38b8113.png)

参与者：

Facade: 外观角色。知道哪些子系统类负责处理请求，将客户的请求代理给适合的子系统处理。

SubSystem:子系统角色。实现子系统功能，处理Facade对象发来的请求。



